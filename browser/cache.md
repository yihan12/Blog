# 概览
> 缓存可以重复利用文件，降低网络负荷，提高网页打开速度，提升用户体验

![image](https://github.com/yihan12/Blog/assets/44987698/bce57bed-cc89-40ff-aed7-e1267eaeb9ef)

![image](https://github.com/yihan12/Blog/assets/44987698/a0ece8ed-6294-4d91-9111-cbe66c95bde2)

# 缓存分类：

从宏观上分为私有缓存和共享缓存，共享缓存就是那些能被各级代理缓存的缓存，私有缓存就是用户专享的，各级代理不能缓存

从微观上可以分为以下几类：

- a、浏览器缓存

- b、代理服务器缓存

- c、CDN缓存

- d、数据库缓存

- e、应用层缓存

### （1）、HTTP缓存：主要分为强缓存与协商缓存

#### 强缓存

强可理解为强制的意思，当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体由 respone header 的cache-control 控制，常见的设置是max-age public private no-cache no-store等，各类设置对应情况：

a、cache-control: max-age=xxxx，public

客户端和代理服务器都可以缓存该资源，客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code200 ，如果用户做了刷新操作，就向服务器发起http请求

b、cache-control: max-age=xxxx，private

只让客户端可以缓存该资源；代理服务器不缓存，客户端在xxx秒内直接读取缓存，statu code:200

c、cache-control: max-age=xxxx，immutable

客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

d、cache-control: no-cache

跳过设置强缓存，但不妨碍设置协商缓存；通常做了强缓存，只有强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端

e、cache-control: no-store

不缓存，客户端、服务器都不缓存

#### 协商缓存

可理解为强缓存就是为资源设置一个有效时间，每次请求资源时都会检查是否过期，只有过期才会去请求服务器（可有效减少请求次数），当强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程协商缓存生效，返回304和Not Modified

在 response header里面的设置etag、last-modified

etag：每个文件具有唯一一个“标识”

last-modified：文件的修改时间，精确到秒

每次请求返回携带response header中的etag和last-modified，在下次请求时request header也会带上，服务端对比etag标识，判断资源是否更改，如更改直接返回新的资源，并更新response header的etag、last-modified，如资源不变，etag、last-modified不变，对客户端来说，每次请求都进行了协商缓存，即：

发请求-->资源是否过期？-->过期（没过期为强缓存）-->请求服务器-->服务器对比资源是否真的过期？-->没过期-->返回304状态码-->客户端用缓存的老资源

当服务端发现资源过期时：

服务器对比资源是否真的过期-？->过期-->返回200状态码-->客户端像第一次接收该资源一样，记录cache-control中的max-age、etag、last-modified等信息

### （2）、本地存储

主要有：localStorage，sessionStorage和cookie，WebSql和IndexDB主要用在前端有大容量存储需求的页面上，如在线编辑浏览器或者网页邮箱，可以将数据存储在浏览器，应该根据不同的场景进行使用

#### Cookie

由服务器生成，且前端也可设置，保存在客户端本地的一个文件，通过response header的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器

其中包含的信息：

a、用户ID、密码、浏览过的网页、停留的时间等信息，当该用户再打开该网站时，网站通过读取Cookie，就可以做出相应的动作，如身份校验、提示语等

b、还保存host属性，即网站的域名或ip，一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件

Cookie 优点：给用户更人性化的使用体验，如自动登陆、提示语；弥补了HTTP无连接特性；可作为站点统计访问量依据

Cookie 缺点：无法解决多人共用电脑问题，具有安全隐患；Cookie文件容易被误删除；可人为修改host文件，可以非法访问目标站点的Cookie；容量较小，不能超过4kb；直接在response header上带数据安全性差

#### LocalStorage（本地存储）

主要是开发人员在前端设置，一旦数据保存在本地后，就可避免再向服务器请求数据，从而减少不必要的数据请求，可以长期存储数据，没有时间限，遵循同源策略，不同的网站不能直接共用

一般浏览器localStorage支持的是5M大小，不同的浏览器会略有不同

LocalStorage 优点：拓展了Cookie的4k限制；可以将第一次请求的5M大小数据直接存储到本地，相比于Cookie节约带宽

LocalStorage 缺点：需要手动删除，否则长期存在；浏览器大小不一，版本的支持也不一样；只支持string类型的存储，JSON对象需要转换；本质上是对字符串的读取，存储内容过多会消耗内存空间，导致卡顿

#### SessionStorage（会话存储）

同样是开发人员在前端设置，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据，大多数浏览器限制为5MB

#### WebSQL

WebSQL 是在浏览器上模拟数据库，可以使用JS来操作SQL进行数据读写，使用 SQL 来操纵客户端数据库的 API（异步），现阶段使用较少

#### IndexedDB

随浏览器的功能日益强大，越来越多的网站将大量数据储存在客户端，可减少从服务器获取数据，直接从本地获取数据

现有浏览器数据储存方案，都不适用于储存大量数据：Cookie 大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 大小在2.5MB 到 10MB 之间（各家浏览器不同），且不提供搜索功能，不能建立自定义的索引。

IndexedDB 是浏览器提供的本地数据库，可被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。但IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库

# 性能优化
### 缓存的作用

> 重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。

其实我们对于页面静态资源的要求就两点
- 1、静态资源加载速度
- 2、页面渲染速度

页面渲染速度建立在资源加载速度之上，但不同资源类型的加载顺序和时机也会对其产生影响，所以缓存的可操作空间非常大

### 缓存的一些应用场景
- 1、每次都加载某个同样的静态文件 => 浪费带宽，重复请求 => 让浏览器使用本地缓存（协商缓存，返回304）
- 2、协商缓存还是要和服务器通信啊 => 有网络请求，不太舒服，感觉很low => 强制浏览器使用本地强缓存（返回200）
- 3、缓存要更新啊，兄弟，网络请求都没了，我咋知道啥时候要更新？=> 让请求（header加上ETag）或者url的修改与文件内容关联（文件名加哈希值）=> 开心，感觉自己很牛逼
- 4、CTO大佬说，我们买了阿里还是腾讯的CDN，几百G呢，用起来啊 => 把静态资源和动态网页分集群部署，静态资源部署到CDN节点上，网页中引用的资源变成对应的部署路径 => html中的资源引用和CDN上的静态资源对应的url地址联系起来了 => 问题来了，更新的时候先上线页面，还是先上线静态资源？（蠢，等到半天三四点啊，用户都睡了，随便你先上哪个）
- 5、老板说：我们的产品将来是国际化的，不存在所谓的半夜三点 => GG，咋办？=> 用非覆盖式发布啊，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面

### 各类缓存技术优缺点
#### 1、cookie  
优点：对于传输部分少量不敏感数据，非常简明有效  
缺点：容量小（4K），不安全（cookie被拦截，很可能暴露session）；原生接口不够友好，需要自己封装；需要指定作用域，不可以跨域调用

#### 2、Web Storage  
容量稍大一点（5M），localStorage可做持久化数据存储  
支持事件通知机制，可以将数据更新的通知发送给监听者  
缺点：本地储存数据都容易被篡改，容易受到XSS攻击  

缓存读取需要依靠js的执行，所以前提条件就是能够读取到html及js代码段，其次文件的版本更新控制会带来更多的代码层面的维护成本，所以LocalStorage更适合关键的业务数据而非静态资源

Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生

#### 3、indexDB
IndexedDb提供了一个结构化的、事务型的、高性能的NoSQL类型的数据库，包含了一组同步/异步API，这部分不好判断优缺点，主要看使用者。

#### 4、Manifest（已经被web标准废除）
优点

可以离线运行  
可以减少资源请求  
可以更新资源

缺点

更新的资源，需要二次刷新才会被页面采用  
不支持增量更新，只有manifest发生变化，所有资源全部重新下载一次  
缺乏足够容错机制，当清单中任意资源文件出现加载异常，都会导致整个manifest策略运行异常  
Manifest被移除是技术发展的必然，请拥抱Service Worker吧  

#### 5、PWA(Service Worker)
这位目前是最炙手可热的缓存明星，是官方建议替代Application Cache（Manifest）的方案  
作为一个独立的线程，是一段在后台运行的脚本，可使web app也具有类似原生App的离线使用、消息推送、后台自动更新等能力  

目前有三个限制（不能明说是缺点）

不能访问 DOM  
不能使用同步 API  
需要HTTPS协议  

### 缓存实践（视项目而定，不要死板）
#### 1、大公司静态资源优化方案
- 配置超长时间的本地缓存 —— 节省带宽，提高性能
- 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
- 静态资源CDN部署 —— 优化网络请求
- 更资源发布路径实现非覆盖式发布 —— 平滑升级

#### 2、利用浏览器缓存机制
- 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
- 对于频繁变动的资源（比如经常需要刷新的首页，资讯论坛新闻类），可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

#### 3、静态资源文件通过Service Worker进行缓存控制和离线化加载

# 浏览器缓存机制：强缓存、协商缓存
![image](https://github.com/yihan12/Blog/assets/44987698/e9755e0a-1e94-4867-b66c-77a616086fce)

### 概述
> 良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度.
> 通常浏览器缓存策略分为两种：强缓存和协商缓存

#### 1、基本原理
- 1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
- 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
- 3）如果前面两者都没有命中，直接从服务器加载资源

#### 2、相同点
如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；

#### 3、不同点
强缓存不发请求到服务器，协商缓存会发请求到服务器。

### 强缓存
通过Expires和Cache-Control两种响应头实现

#### 1、Expires
Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

Expires: Wed, 11 May 2018 07:20:00 GMT
#### 2、Cache-Control
Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间

- Cache-Control: max-age=315360000
题外tips
Cache-Control: no-cache不会缓存数据到本地的说法是错误的，详情《HTTP权威指南》P182

![image](https://github.com/yihan12/Blog/assets/44987698/ff840908-aba6-45fa-8d3d-542ea8c1387b)

- Cache-Control: no-store才是真正的不缓存数据到本地
- Cache-Control: public可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
- Cache-Control: private只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存

![image](https://github.com/yihan12/Blog/assets/44987698/a36a6bc9-eaa9-409e-af30-5383a057e141)



# 概览
> 缓存可以重复利用文件，降低网络负荷，提高网页打开速度，提升用户体验

![image](https://github.com/yihan12/Blog/assets/44987698/bce57bed-cc89-40ff-aed7-e1267eaeb9ef)

![image](https://github.com/yihan12/Blog/assets/44987698/a0ece8ed-6294-4d91-9111-cbe66c95bde2)

# 缓存分类：

从宏观上分为私有缓存和共享缓存，共享缓存就是那些能被各级代理缓存的缓存，私有缓存就是用户专享的，各级代理不能缓存

从微观上可以分为以下几类：

- a、浏览器缓存

- b、代理服务器缓存

- c、CDN缓存

- d、数据库缓存

- e、应用层缓存

### （1）、HTTP缓存：主要分为强缓存与协商缓存

#### 强缓存

强可理解为强制的意思，当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体由 respone header 的cache-control 控制，常见的设置是max-age public private no-cache no-store等，各类设置对应情况：

a、cache-control: max-age=xxxx，public

客户端和代理服务器都可以缓存该资源，客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code200 ，如果用户做了刷新操作，就向服务器发起http请求

b、cache-control: max-age=xxxx，private

只让客户端可以缓存该资源；代理服务器不缓存，客户端在xxx秒内直接读取缓存，statu code:200

c、cache-control: max-age=xxxx，immutable

客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存，statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

d、cache-control: no-cache

跳过设置强缓存，但不妨碍设置协商缓存；通常做了强缓存，只有强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端

e、cache-control: no-store

不缓存，客户端、服务器都不缓存

#### 协商缓存

可理解为强缓存就是为资源设置一个有效时间，每次请求资源时都会检查是否过期，只有过期才会去请求服务器（可有效减少请求次数），当强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程协商缓存生效，返回304和Not Modified

在 response header里面的设置etag、last-modified

etag：每个文件具有唯一一个“标识”

last-modified：文件的修改时间，精确到秒

每次请求返回携带response header中的etag和last-modified，在下次请求时request header也会带上，服务端对比etag标识，判断资源是否更改，如更改直接返回新的资源，并更新response header的etag、last-modified，如资源不变，etag、last-modified不变，对客户端来说，每次请求都进行了协商缓存，即：

发请求-->资源是否过期？-->过期（没过期为强缓存）-->请求服务器-->服务器对比资源是否真的过期？-->没过期-->返回304状态码-->客户端用缓存的老资源

当服务端发现资源过期时：

服务器对比资源是否真的过期-？->过期-->返回200状态码-->客户端像第一次接收该资源一样，记录cache-control中的max-age、etag、last-modified等信息

### （2）、本地存储

主要有：localStorage，sessionStorage和cookie，WebSql和IndexDB主要用在前端有大容量存储需求的页面上，如在线编辑浏览器或者网页邮箱，可以将数据存储在浏览器，应该根据不同的场景进行使用

#### Cookie

由服务器生成，且前端也可设置，保存在客户端本地的一个文件，通过response header的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器

其中包含的信息：

a、用户ID、密码、浏览过的网页、停留的时间等信息，当该用户再打开该网站时，网站通过读取Cookie，就可以做出相应的动作，如身份校验、提示语等

b、还保存host属性，即网站的域名或ip，一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件

Cookie 优点：给用户更人性化的使用体验，如自动登陆、提示语；弥补了HTTP无连接特性；可作为站点统计访问量依据

Cookie 缺点：无法解决多人共用电脑问题，具有安全隐患；Cookie文件容易被误删除；可人为修改host文件，可以非法访问目标站点的Cookie；容量较小，不能超过4kb；直接在response header上带数据安全性差

#### LocalStorage（本地存储）

主要是开发人员在前端设置，一旦数据保存在本地后，就可避免再向服务器请求数据，从而减少不必要的数据请求，可以长期存储数据，没有时间限，遵循同源策略，不同的网站不能直接共用

一般浏览器localStorage支持的是5M大小，不同的浏览器会略有不同

LocalStorage 优点：拓展了Cookie的4k限制；可以将第一次请求的5M大小数据直接存储到本地，相比于Cookie节约带宽

LocalStorage 缺点：需要手动删除，否则长期存在；浏览器大小不一，版本的支持也不一样；只支持string类型的存储，JSON对象需要转换；本质上是对字符串的读取，存储内容过多会消耗内存空间，导致卡顿

#### SessionStorage（会话存储）

同样是开发人员在前端设置，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据，大多数浏览器限制为5MB

#### WebSQL

WebSQL 是在浏览器上模拟数据库，可以使用JS来操作SQL进行数据读写，使用 SQL 来操纵客户端数据库的 API（异步），现阶段使用较少

#### IndexedDB

随浏览器的功能日益强大，越来越多的网站将大量数据储存在客户端，可减少从服务器获取数据，直接从本地获取数据

现有浏览器数据储存方案，都不适用于储存大量数据：Cookie 大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 大小在2.5MB 到 10MB 之间（各家浏览器不同），且不提供搜索功能，不能建立自定义的索引。

IndexedDB 是浏览器提供的本地数据库，可被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。但IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库

# 缓存的作用

> 重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。

其实我们对于页面静态资源的要求就两点
- 1、静态资源加载速度
- 2、页面渲染速度

页面渲染速度建立在资源加载速度之上，但不同资源类型的加载顺序和时机也会对其产生影响，所以缓存的可操作空间非常大



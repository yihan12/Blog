在前端路由中，`history` 模式和 `hash` 模式是两种常见的路由实现方式，它们存在多方面的区别，以下为你详细介绍：
# 区别
### 1. URL 表现形式
- **hash 模式**：URL 中会带有 `#` 符号，`#` 后面的内容被称为哈希值。例如 `https://example.com/#/home`，其中 `#/home` 就是哈希值。当哈希值发生变化时，页面不会向服务器发送请求。
- **history 模式**：URL 看起来和普通的 URL 一样，没有特殊的符号作为标识。例如 `https://example.com/home`。这种模式下，URL 的变化更加直观，符合用户对传统 URL 的认知。

### 2. 实现原理
- **hash 模式**：利用了浏览器的 `hashchange` 事件。当 URL 中的哈希值发生变化时，会触发 `hashchange` 事件，前端可以监听这个事件，根据新的哈希值来渲染不同的页面内容。由于哈希值的变化不会向服务器发送请求，所以页面不会重新加载。
- **history 模式**：借助 HTML5 的 History API 来实现，主要使用 `history.pushState()` 和 `history.replaceState()` 方法。`pushState()` 方法可以向浏览器历史记录中添加一条新的记录，`replaceState()` 方法则可以替换当前的历史记录。当用户点击浏览器的前进、后退按钮或者调用 `pushState()`、`replaceState()` 方法时，URL 会发生变化，但不会触发页面的重新加载。

### 3. 服务器端处理
- **hash 模式**：由于哈希值的变化不会发送请求到服务器，所以服务器端不需要对哈希值进行特殊处理。服务器只需要返回一个固定的 HTML 文件，前端根据哈希值来渲染不同的内容。
- **history 模式**：在这种模式下，当用户直接访问一个 URL 或者刷新页面时，浏览器会向服务器发送请求。服务器需要配置相应的路由规则，确保无论用户访问哪个 URL，都能返回前端应用的 HTML 文件，然后由前端路由来处理具体的页面渲染。如果服务器没有正确配置，可能会出现 404 错误。

### 4. 兼容性
- **hash 模式**：兼容性较好，几乎所有的浏览器都支持 `hashchange` 事件，因此可以在各种浏览器环境中使用。
- **history 模式**：依赖于 HTML5 的 History API，在一些旧版本的浏览器中可能不支持。如果需要支持旧版本浏览器，可能需要进行额外的兼容性处理。

### 5. 应用场景
- **hash 模式**：适用于对兼容性要求较高，或者不需要服务器端配合的场景。例如一些单页面应用，只需要在前端进行路由切换，不需要服务器进行特殊处理。
- **history 模式**：适合对 URL 美观性和用户体验要求较高的场景，尤其是需要与服务器进行深度交互的应用。例如一些需要 SEO 优化的网站，因为搜索引擎可以更好地识别和索引没有 `#` 符号的 URL。 

# 总结
hash模式会携带#，history不会；  
hash使用location API 。利用了浏览器的 `hashchange` 事件，借助 HTML5 的 History API 来实现，主要使用 `history.pushState()` 和 `history.replaceState()` 方法；  
has值变化不会发送请求给服务器，当用户直接访问一个 URL 或者刷新页面时，浏览器会向服务器发送请求，还需要配置404页面；  
hash兼容性更好；  

